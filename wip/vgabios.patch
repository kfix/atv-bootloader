--- vgabios/int15.c	(revision 0)
+++ vgabios/int15.c	(revision 0)
@@ -0,0 +1,12 @@
+#include <stdio.h>
+#include "test.h"
+
+void x86emu_dump_xregs();
+
+int int15_handler(void)
+{
+	printf("\nint15 encountered.\n");
+	//x86emu_dump_xregs();
+	X86_EAX = 0;
+	return 1;
+}
--- vgabios/int16.c	(revision 0)
+++ vgabios/int16.c	(revision 0)
@@ -0,0 +1,7 @@
+#include <stdio.h>
+
+int int16_handler(void)
+{
+	printf("\nint16: keyboard not supported right now.\n");
+	return 1;
+}
--- vgabios/pci-userspace.c	(revision 0)
+++ vgabios/pci-userspace.c	(revision 0)
@@ -0,0 +1,160 @@
+#include "../types.h"
+
+#include "pci.h"
+#include "sys_pci.h"
+
+#define PCITAG struct pci_filter *
+
+#define DEBUG_PCI 1
+
+struct pci_access *pacc;
+struct pci_dev *dev;
+
+struct pci_filter ltag;
+
+
+
+int pciNumBuses = 0;
+
+int pciInit(void)
+{
+	pacc = pci_alloc();
+
+	pci_init(pacc);
+	pci_scan_bus(pacc);
+	for (dev = pacc->devices; dev; dev = dev->next) {
+		pci_fill_info(dev, PCI_FILL_IDENT | PCI_FILL_BASES);
+	}
+	return 0;
+}
+
+int pciExit(void)
+{
+	pci_cleanup(pacc);
+	return 0;
+}
+
+PCITAG findPci(unsigned short bx)
+{
+	PCITAG tag = &ltag;
+
+	int bus = (bx >> 8) & 0xFF;
+	int slot = (bx >> 3) & 0x1F;
+	int func = bx & 0x7;
+
+	tag->bus = bus;
+	tag->slot = slot;
+	tag->func = func;
+
+#if LIBPCI_CHECK_VERSION(2,1,99)
+	if (pci_get_dev(pacc, 0, bus, slot, func))
+#else
+	if (pci_get_dev(pacc, bus, slot, func))
+#endif
+		return tag;
+
+	return NULL;
+}
+
+u32 pciSlotBX(PCITAG tag)
+{
+	return (tag->bus << 8) | (tag->slot << 3) | (tag->func);
+}
+
+u8 pciReadByte(PCITAG tag, u32 idx)
+{
+	struct pci_dev *d;
+#if LIBPCI_CHECK_VERSION(2,1,99)
+	if ((d = pci_get_dev(pacc, 0, tag->bus, tag->slot, tag->func)))
+#else
+	if ((d = pci_get_dev(pacc, tag->bus, tag->slot, tag->func)))
+#endif
+		return pci_read_byte(d, idx);
+#ifdef DEBUG_PCI
+	printf("PCI: device not found while read byte (%x:%x.%x)\n",
+	       tag->bus, tag->slot, tag->func);
+#endif
+	return 0;
+}
+
+u16 pciReadWord(PCITAG tag, u32 idx)
+{
+	struct pci_dev *d;
+#if LIBPCI_CHECK_VERSION(2,1,99)
+	if ((d = pci_get_dev(pacc, 0, tag->bus, tag->slot, tag->func)))
+#else
+	if ((d = pci_get_dev(pacc, tag->bus, tag->slot, tag->func)))
+#endif
+		return pci_read_word(d, idx);
+#ifdef DEBUG_PCI
+	printf("PCI: device not found while read word (%x:%x.%x)\n",
+	       tag->bus, tag->slot, tag->func);
+#endif
+	return 0;
+}
+
+u32 pciReadLong(PCITAG tag, u32 idx)
+{
+	struct pci_dev *d;
+#if LIBPCI_CHECK_VERSION(2,1,99)
+	if ((d = pci_get_dev(pacc, 0, tag->bus, tag->slot, tag->func)))
+#else
+	if ((d = pci_get_dev(pacc, tag->bus, tag->slot, tag->func)))
+#endif
+		return pci_read_long(d, idx);
+#ifdef DEBUG_PCI
+	printf("PCI: device not found while read long (%x:%x.%x)\n",
+	       tag->bus, tag->slot, tag->func);
+#endif
+	return 0;
+}
+
+
+void pciWriteLong(PCITAG tag, u32 idx, u32 data)
+{
+	struct pci_dev *d;
+#if LIBPCI_CHECK_VERSION(2,1,99)
+	if ((d = pci_get_dev(pacc, 0, tag->bus, tag->slot, tag->func)))
+#else
+	if ((d = pci_get_dev(pacc, tag->bus, tag->slot, tag->func)))
+#endif
+		pci_write_long(d, idx, data);
+#ifdef DEBUG_PCI
+	else
+		printf("PCI: device not found while write long (%x:%x.%x)\n",
+		       tag->bus, tag->slot, tag->func);
+#endif
+}
+
+void pciWriteWord(PCITAG tag, u32 idx, u16 data)
+{
+	struct pci_dev *d;
+#if LIBPCI_CHECK_VERSION(2,1,99)
+	if ((d = pci_get_dev(pacc, 0, tag->bus, tag->slot, tag->func)))
+#else
+	if ((d = pci_get_dev(pacc, tag->bus, tag->slot, tag->func)))
+#endif
+		pci_write_word(d, idx, data);
+#ifdef DEBUG_PCI
+	else
+		printf("PCI: device not found while write word (%x:%x.%x)\n",
+		       tag->bus, tag->slot, tag->func);
+#endif
+
+}
+
+void pciWriteByte(PCITAG tag, u32 idx, u8 data)
+{
+	struct pci_dev *d;
+#if LIBPCI_CHECK_VERSION(2,1,99)
+	if ((d = pci_get_dev(pacc, 0, tag->bus, tag->slot, tag->func)))
+#else
+	if ((d = pci_get_dev(pacc, tag->bus, tag->slot, tag->func)))
+#endif
+		pci_write_long(d, idx, data);
+#ifdef DEBUG_PCI
+	else
+		printf("PCI: device not found while write long (%x:%x.%x)\n",
+		       tag->bus, tag->slot, tag->func);
+#endif
+}
--- vgabios/pci-userspace.h	(revision 0)
+++ vgabios/pci-userspace.h	(revision 0)
@@ -0,0 +1,57 @@
+#include "../types.h"
+
+#include "pci.h"
+
+typedef unsigned long pciaddr_t;
+typedef u8 byte;
+typedef u16 word;
+
+struct pci_dev {
+	struct pci_dev *next;	/* Next device in the chain */
+	word bus;		/* Higher byte can select host bridges */
+	byte dev, func;		/* Device and function */
+
+	/* These fields are set by pci_fill_info() */
+	int known_fields;	/* Set of info fields already known */
+	word vendor_id, device_id;	/* Identity of the device */
+	int irq;		/* IRQ number */
+	pciaddr_t base_addr[6];	/* Base addresses */
+	pciaddr_t size[6];	/* Region sizes */
+	pciaddr_t rom_base_addr;	/* Expansion ROM base address */
+	pciaddr_t rom_size;	/* Expansion ROM size */
+
+	/* Fields used internally: */
+	void *access;
+	void *methods;
+	byte *cache;		/* Cached information */
+	int cache_len;
+	int hdrtype;		/* Direct methods: header type */
+	void *aux;		/* Auxillary data */
+};
+
+
+struct pci_filter {
+	int bus, slot, func;	/* -1 = ANY */
+	int vendor, device;
+};
+
+
+#define PCITAG struct pci_filter *
+#define pciVideoPtr struct pci_dev *
+
+extern int pciNumBuses;
+
+int pciInit(void);
+int pciExit(void);
+
+
+PCITAG findPci(unsigned short bx);
+u32 pciSlotBX(pciVideoPtr pvp);
+
+void pciWriteLong(PCITAG tag, u32 idx, u32 data);
+void pciWriteWord(PCITAG tag, u32 idx, u16 data);
+void pciWriteByte(PCITAG tag, u32 idx, u8 data);
+
+u32 pciReadLong(PCITAG tag, u32 idx);
+u16 pciReadWord(PCITAG tag, u32 idx);
+u8 pciReadByte(PCITAG tag, u32 idx);
--- vgabios/sys_pci.c	(revision 0)
+++ vgabios/sys_pci.c	(revision 0)
@@ -0,0 +1,55 @@
+/*
+ * pci.h:
+ *
+ * Copyright (c) 2006 James McKenzie <james@fishsoup.dhs.org>,
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include "sys_pci.h"
+#include "sys_io.h"
+
+/* PCI config read/write */
+unsigned char
+conf1_read_8(int bus, int devfn, int off)
+{
+  int addr = 0xcfc + (off & 3);
+  outl(0x80000000 | (bus << 16) | (devfn << 8) | (off & ~3), 0x0cf8);
+  return inb(addr);
+}
+
+unsigned short
+conf1_read_16(int bus, int devfn, int off)
+{
+  int addr = 0xcfc + (off & 3);
+  outl(0x80000000 | (bus << 16) | (devfn << 8) | (off & ~3), 0x0cf8);
+  return inw(addr);
+}
+
+unsigned long
+conf1_read_32(int bus, int devfn, int off)
+{
+  int addr = 0xcfc + (off & 3);
+  outl(0x80000000 | (bus << 16) | (devfn << 8) | (off & ~3), 0x0cf8);
+  return inl(addr);
+}
+
+void
+conf1_write_8(int bus, int devfn, int off, unsigned char val)
+{
+  int addr = 0xcfc + (off & 3);
+  outl(0x80000000 | (bus << 16) | (devfn << 8) | (off & ~3), 0x0cf8);
+  outb(val, addr);
+}
--- vgabios/sys_io.h	(revision 0)
+++ vgabios/sys_io.h	(revision 0)
@@ -0,0 +1,39 @@
+#ifndef __SYS_IO_H__
+#define __SYS_IO_H__
+
+/* IO port input/output */
+
+static inline void outb(unsigned char value, unsigned short port) {
+    __asm__ __volatile__ ("out" "b" " %" "b" "0,%" "w" "1"::"a" (value),
+            "Nd" (port));
+}
+
+static inline void outw(unsigned short value, unsigned short port) {
+    __asm__ __volatile__ ("out" "w" " %" "w" "0,%" "w" "1"::"a" (value),
+            "Nd" (port));
+}
+
+static inline void outl(unsigned long value, unsigned short port) {
+    __asm__ __volatile__ ("out" "l" " %" "0,%" "w" "1"::"a" (value),
+            "Nd" (port));
+}
+
+static inline unsigned char inb(unsigned short port) {
+    unsigned char _v;
+    __asm__ __volatile__ ("in" "b" " %" "w" "1,%" "" "0":"=a" (_v):"Nd" (port));
+    return _v;
+}
+
+static inline unsigned short inw(unsigned short port) {
+    unsigned short _v;
+    __asm__ __volatile__ ("in" "w" " %" "w" "1,%" "" "0":"=a" (_v):"Nd" (port));
+    return _v;
+}
+
+static inline unsigned long inl(unsigned short port) {
+    unsigned long _v;
+    __asm__ __volatile__ ("in" "l" " %" "w" "1,%" "" "0":"=a" (_v):"Nd" (port));
+    return _v;
+}
+
+#endif /* __SYS_IO_H__ */
--- vgabios/int1a.c	(revision 0)
+++ vgabios/int1a.c	(revision 0)
@@ -0,0 +1,172 @@
+//#include <stdio.h>
+#include "test.h"
+#include "pci-userspace.h"
+
+#define DEBUG_INT1A
+
+#define SUCCESSFUL              0x00
+#define DEVICE_NOT_FOUND        0x86
+#define BAD_REGISTER_NUMBER     0x87
+
+void x86emu_dump_xregs(void);
+extern int verbose;
+
+
+int int1A_handler()
+{
+	PCITAG tag;
+	pciVideoPtr pvp = NULL;
+
+	if (verbose) {
+		printf("\nint1a encountered.\n");
+		//x86emu_dump_xregs();
+	}
+
+	switch (X86_AX) {
+	case 0xb101:
+		X86_EAX = 0x00;	/* no config space/special cycle support */
+		X86_AL = 0x01;	/* config mechanism 1 */
+		X86_EDX = 0x20494350;	/* " ICP" */
+		X86_EBX = 0x0210;	/* Version 2.10 */
+		X86_ECX &= 0xFF00;
+		X86_ECX |= (pciNumBuses & 0xFF);	/* Max bus number in system */
+		X86_EFLAGS &= ~((unsigned long) 0x01);	/* clear carry flag */
+#ifdef DEBUG_INT1A
+		if (verbose)
+			printf("PCI bios present.\n");
+#endif
+		return 1;
+	case 0xb102:
+		if (X86_DX == pvp->vendor_id && X86_CX == pvp->device_id && X86_ESI == 0) {
+			X86_EAX = X86_AL | (SUCCESSFUL << 8);
+			X86_EFLAGS &= ~((unsigned long) 0x01);	/* clear carry flag */
+			X86_EBX = pciSlotBX(pvp);
+		}
+#ifdef SHOW_ALL_DEVICES
+		else if ((pvp = xf86FindPciDeviceVendor(X86_EDX, X86_ECX, X86_ESI, pvp))) {
+			X86_EAX = X86_AL | (SUCCESSFUL << 8);
+			X86_EFLAGS &= ~((unsigned long) 0x01);	/* clear carry flag */
+			X86_EBX = pciSlotBX(pvp);
+		}
+#endif
+		else {
+			X86_EAX = X86_AL | (DEVICE_NOT_FOUND << 8);
+			X86_EFLAGS |= ((unsigned long) 0x01);	/* set carry flag */
+		}
+#ifdef DEBUG_INT1A
+		printf("eax=0x%x ebx=0x%x eflags=0x%x\n", X86_EAX, X86_EBX, X86_EFLAGS);
+#endif
+		return 1;
+	case 0xb103:
+#if 0
+		if (X86_CL == pvp->interface &&
+		    X86_CH == pvp->subclass &&
+		    ((X86_ECX & 0xFFFF0000) >> 16) == pvp->class) {
+			X86_EAX = X86_AL | (SUCCESSFUL << 8);
+			X86_EBX = pciSlotBX(pvp);
+			X86_EFLAGS &= ~((unsigned long) 0x01);	/* clear carry flag */
+		}
+#else
+		/* FIXME: dirty hack */
+		if (0);
+#endif
+#ifdef SHOW_ALL_DEVICES
+		else if ((pvp = FindPciClass(X86_CL, X86_CH,
+					     (X86_ECX & 0xffff0000) >> 16,
+					     X86_ESI, pvp))) {
+			X86_EAX = X86_AL | (SUCCESSFUL << 8);
+			X86_EFLAGS &= ~((unsigned long) 0x01);	/* clear carry flag */
+			X86_EBX = pciSlotBX(pvp);
+		}
+#endif
+		else {
+			X86_EAX = X86_AL | (DEVICE_NOT_FOUND << 8);
+			X86_EFLAGS |= ((unsigned long) 0x01);	/* set carry flag */
+		}
+#ifdef DEBUG_INT1A
+		printf("eax=0x%x eflags=0x%x\n", X86_EAX, X86_EFLAGS);
+#endif
+		return 1;
+	case 0xb108:
+		if ((tag = findPci(X86_EBX))) {
+			X86_CL = pciReadByte(tag, X86_EDI);
+			X86_EAX = X86_AL | (SUCCESSFUL << 8);
+			X86_EFLAGS &= ~((unsigned long) 0x01);	/* clear carry flag */
+		} else {
+			X86_EAX = X86_AL | (BAD_REGISTER_NUMBER << 8);
+			X86_EFLAGS |= ((unsigned long) 0x01);	/* set carry flag */
+		}
+#ifdef DEBUG_INT1A
+		printf("eax=0x%x ecx=0x%x eflags=0x%x\n", X86_EAX, X86_ECX, X86_EFLAGS);
+#endif
+		return 1;
+	case 0xb109:
+		if ((tag = findPci(X86_EBX))) {
+			X86_CX = pciReadWord(tag, X86_EDI);
+			X86_EAX = X86_AL | (SUCCESSFUL << 8);
+			X86_EFLAGS &= ~((unsigned long) 0x01);	/* clear carry flag */
+		} else {
+			X86_EAX = X86_AL | (BAD_REGISTER_NUMBER << 8);
+			X86_EFLAGS |= ((unsigned long) 0x01);	/* set carry flag */
+		}
+#ifdef DEBUG_INT1A
+		printf("eax=0x%x ecx=0x%x eflags=0x%x\n", X86_EAX, X86_ECX, X86_EFLAGS);
+#endif
+		return 1;
+	case 0xb10a:
+		if ((tag = findPci(X86_EBX))) {
+			X86_ECX = pciReadLong(tag, X86_EDI);
+			X86_EAX = X86_AL | (SUCCESSFUL << 8);
+			X86_EFLAGS &= ~((unsigned long) 0x01);	/* clear carry flag */
+		} else {
+			X86_EAX = X86_AL | (BAD_REGISTER_NUMBER << 8);
+			X86_EFLAGS |= ((unsigned long) 0x01);	/* set carry flag */
+		}
+#ifdef DEBUG_INT1A
+		printf("eax=0x%x ecx=0x%x eflags=0x%x\n", X86_EAX, X86_ECX, X86_EFLAGS);
+#endif
+		return 1;
+	case 0xb10b:
+		if ((tag = findPci(X86_EBX))) {
+			pciWriteByte(tag, X86_EDI, X86_CL);
+			X86_EAX = X86_AL | (SUCCESSFUL << 8);
+			X86_EFLAGS &= ~((unsigned long) 0x01);	/* clear carry flag */
+		} else {
+			X86_EAX = X86_AL | (BAD_REGISTER_NUMBER << 8);
+			X86_EFLAGS |= ((unsigned long) 0x01);	/* set carry flag */
+		}
+#ifdef DEBUG_INT1A
+		printf("eax=0x%x eflags=0x%x\n", X86_EAX, X86_EFLAGS);
+#endif
+		return 1;
+	case 0xb10c:
+		if ((tag = findPci(X86_EBX))) {
+			pciWriteWord(tag, X86_EDI, X86_CX);
+			X86_EAX = X86_AL | (SUCCESSFUL << 8);
+			X86_EFLAGS &= ~((unsigned long) 0x01);	/* clear carry flag */
+		} else {
+			X86_EAX = X86_AL | (BAD_REGISTER_NUMBER << 8);
+			X86_EFLAGS |= ((unsigned long) 0x01);	/* set carry flag */
+		}
+#ifdef DEBUG_INT1A
+		printf("eax=0x%x eflags=0x%x\n", X86_EAX, X86_EFLAGS);
+#endif
+		return 1;
+	case 0xb10d:
+		if ((tag = findPci(X86_EBX))) {
+			pciWriteLong(tag, X86_EDI, X86_ECX);
+			X86_EAX = X86_AL | (SUCCESSFUL << 8);
+			X86_EFLAGS &= ~((unsigned long) 0x01);	/* clear carry flag */
+		} else {
+			X86_EAX = X86_AL | (BAD_REGISTER_NUMBER << 8);
+			X86_EFLAGS |= ((unsigned long) 0x01);	/* set carry flag */
+		}
+#ifdef DEBUG_INT1A
+		printf("eax=0x%x eflags=0x%x\n", X86_EAX, X86_EFLAGS);
+#endif
+		return 1;
+	default:
+		printf("int1a: subfunction not implemented.\n");
+		return 0;
+	}
+}
--- vgabios/README	(revision 0)
+++ vgabios/README	(revision 0)
@@ -0,0 +1,32 @@
+James Mckenzie, May 2006.
+
+This is a horrible hack.
+
+Just before elilo calls into the kernel it calls vga_init
+and passes a pointer to the kernels parameter table.
+
+vga_init does the following:
+
+1) search through the RAM (from the compressed EFI firmware rom)
+   for the intel VGA bios.
+2) setup a real mode x86 emulator and copy the rom into 0xc0000 in 
+   the emulator, trap all the interrupt vectors in the emulator
+   to stop the VGA bios trying to call the system bios.
+3) execute the VGA bios rom. The VGA bios rom reads the EDID information
+   from the monitor and modifies! itself.
+4) tell the ICH7 chipset to map RW memory at 0xc0000, and to point 
+   0xa0000 to the video card.
+5) copy the interrupt vectors (specifically int 0x10), the BIOS parameter 
+   table, and the ROM from the emulator into real memory.
+6) in the emulator execute code equivalent to the linux kernel's video.S
+   and set the boot parameters accordingly
+7) transfer control back to the kernel.
+
+Thanks to Matthew Garrett, whose work with vbetool this 
+builds on.
+
+To get this to work, you need to apply the patches in the patches directory.
+The first to elilo which links this code in, and the second to the kernel
+which tells it to use the legacy VGA mode even in the presence of EFI.
+
+
--- vgabios/helper_mem.c	(revision 0)
+++ vgabios/helper_mem.c	(revision 0)
@@ -0,0 +1,311 @@
+/* $XFree86: xc/programs/Xserver/hw/xfree86/int10/helper_mem.c,v 1.21 2001/05/22 16:24:37 tsi Exp $ */
+/*
+ *                   XFree86 int10 module
+ *   execute BIOS int 10h calls in x86 real mode environment
+ *                 Copyright 1999 Egbert Eich
+ */
+#define _INT10_PRIVATE
+
+#define REG pInt
+#if 0
+typedef enum {
+	OPT_NOINT10,
+	OPT_INIT_PRIMARY,
+	OPT_BIOS_LOCATION
+} INT10Opts;
+
+static const OptionInfoRec INT10Options[] = {
+	{OPT_NOINT10, "NoINT10", OPTV_BOOLEAN, {0}, FALSE},
+	{OPT_INIT_PRIMARY, "InitPrimary", OPTV_BOOLEAN, {0}, FALSE},
+	{OPT_BIOS_LOCATION, "BiosLocation", OPTV_STRING, {0}, FALSE},
+	{-1, NULL, OPTV_NONE, {0}, FALSE},
+};
+#endif
+
+#ifdef DEBUG
+void dprint(unsigned long start, unsigned long size)
+{
+	int i, j;
+	char *c = (char *) start;
+
+	for (j = 0; j < (size >> 4); j++) {
+		char *d = c;
+		printf("\n0x%lx:  ", (unsigned long) c);
+		for (i = 0; i < 16; i++)
+			printf("%2.2x ", (unsigned char) (*(c++)));
+		c = d;
+		for (i = 0; i < 16; i++) {
+			printf("%c", ((((u8) (*c)) > 32) && (((u8) (*c)) < 128)) ?
+			       (unsigned char) (*(c)) : '.');
+			c++;
+		}
+	}
+	printf("\n");
+}
+#endif /* DEBUG */
+
+#if 0
+#ifndef _PC
+/*
+ * here we are really paranoid about faking a "real"
+ * BIOS. Most of this information was pulled from
+ * dosemu.
+ */
+void setup_int_vect(void)
+{
+	int i;
+
+	/* let the int vects point to the SYS_BIOS seg */
+	for (i = 0; i < 0x80; i++) {
+		MEM_WW(i << 2, 0);
+		MEM_WW((i << 2) + 2, SYS_BIOS >> 4);
+	}
+
+	reset_int_vect(current);
+	/* font tables default location (int 1F) */
+	MEM_WW(0x1f << 2, 0xfa6e);
+
+	/* int 11 default location (Get Equipment Configuration) */
+	MEM_WW(0x11 << 2, 0xf84d);
+	/* int 12 default location (Get Conventional Memory Size) */
+	MEM_WW(0x12 << 2, 0xf841);
+	/* int 15 default location (I/O System Extensions) */
+	MEM_WW(0x15 << 2, 0xf859);
+	/* int 1A default location (RTC, PCI and others) */
+	MEM_WW(0x1a << 2, 0xff6e);
+	/* int 05 default location (Bound Exceeded) */
+	MEM_WW(0x05 << 2, 0xff54);
+	/* int 08 default location (Double Fault) */
+	MEM_WW(0x08 << 2, 0xfea5);
+	/* int 13 default location (Disk) */
+	MEM_WW(0x13 << 2, 0xec59);
+	/* int 0E default location (Page Fault) */
+	MEM_WW(0x0e << 2, 0xef57);
+	/* int 17 default location (Parallel Port) */
+	MEM_WW(0x17 << 2, 0xefd2);
+	/* fdd table default location (int 1e) */
+	MEM_WW(0x1e << 2, 0xefc7);
+
+	/* Set Equipment flag to VGA */
+	i = MEM_RB(0x0410) & 0xCF;
+	MEM_WB(0x0410, i);
+	/* XXX Perhaps setup more of the BDA here.  See also int42(0x00). */
+}
+#endif
+
+int setup_system_bios(void *base_addr)
+{
+	char *base = (char *) base_addr;
+
+	/*
+	 * we trap the "industry standard entry points" to the BIOS
+	 * and all other locations by filling them with "hlt"
+	 * TODO: implement hlt-handler for these
+	 */
+	memset(base, 0xf4, 0x10000);
+
+	/* set bios date */
+	strcpy(base + 0x0FFF5, "06/11/99");
+	/* set up eisa ident string */
+	strcpy(base + 0x0FFD9, "PCI_ISA");
+	/* write system model id for IBM-AT */
+	*((unsigned char *) (base + 0x0FFFE)) = 0xfc;
+
+	return 1;
+}
+
+void reset_int_vect(void)
+{
+	/*
+	 * This table is normally located at 0xF000:0xF0A4.  However, int 0x42,
+	 * function 0 (Mode Set) expects it (or a copy) somewhere in the bottom
+	 * 64kB.  Note that because this data doesn't survive POST, int 0x42 should
+	 * only be used during EGA/VGA BIOS initialisation.
+	 */
+	static const u8 VideoParms[] = {
+		/* Timing for modes 0x00 & 0x01 */
+		0x38, 0x28, 0x2d, 0x0a, 0x1f, 0x06, 0x19, 0x1c,
+		0x02, 0x07, 0x06, 0x07, 0x00, 0x00, 0x00, 0x00,
+		/* Timing for modes 0x02 & 0x03 */
+		0x71, 0x50, 0x5a, 0x0a, 0x1f, 0x06, 0x19, 0x1c,
+		0x02, 0x07, 0x06, 0x07, 0x00, 0x00, 0x00, 0x00,
+		/* Timing for modes 0x04, 0x05 & 0x06 */
+		0x38, 0x28, 0x2d, 0x0a, 0x7f, 0x06, 0x64, 0x70,
+		0x02, 0x01, 0x06, 0x07, 0x00, 0x00, 0x00, 0x00,
+		/* Timing for mode 0x07 */
+		0x61, 0x50, 0x52, 0x0f, 0x19, 0x06, 0x19, 0x19,
+		0x02, 0x0d, 0x0b, 0x0c, 0x00, 0x00, 0x00, 0x00,
+		/* Display page lengths in little endian order */
+		0x00, 0x08,	/* Modes 0x00 and 0x01 */
+		0x00, 0x10,	/* Modes 0x02 and 0x03 */
+		0x00, 0x40,	/* Modes 0x04 and 0x05 */
+		0x00, 0x40,	/* Modes 0x06 and 0x07 */
+		/* Number of columns for each mode */
+		40, 40, 80, 80, 40, 40, 80, 80,
+		/* CGA Mode register value for each mode */
+		0x2c, 0x28, 0x2d, 0x29, 0x2a, 0x2e, 0x1e, 0x29,
+		/* Padding */
+		0x00, 0x00, 0x00, 0x00
+	};
+	int i;
+
+	for (i = 0; i < sizeof(VideoParms); i++)
+		MEM_WB(i + (0x1000 - sizeof(VideoParms)), VideoParms[i]);
+	MEM_WW(0x1d << 2, 0x1000 - sizeof(VideoParms));
+	MEM_WW((0x1d << 2) + 2, 0);
+
+	printf("SETUP INT\n");
+	MEM_WW(0x10 << 2, 0xf065);
+	MEM_WW((0x10 << 2) + 2, SYS_BIOS >> 4);
+	MEM_WW(0x42 << 2, 0xf065);
+	MEM_WW((0x42 << 2) + 2, SYS_BIOS >> 4);
+	MEM_WW(0x6D << 2, 0xf065);
+	MEM_WW((0x6D << 2) + 2, SYS_BIOS >> 4);
+}
+
+void set_return_trap(void)
+{
+	/*
+	 * Here we set the exit condition:  We return when we encounter
+	 * 'hlt' (=0xf4), which we locate at address 0x600 in x86 memory.
+	 */
+	MEM_WB(0x0600, 0xf4);
+
+	/*
+	 * Allocate a segment for the stack
+	 */
+	xf86Int10AllocPages(1, current->stackseg);
+}
+
+void *xf86HandleInt10Options(ScrnInfoPtr pScrn, int entityIndex)
+{
+	EntityInfoPtr pEnt = xf86GetEntityInfo(entityIndex);
+	OptionInfoPtr options = NULL;
+
+	if (pEnt->device) {
+		pointer configOptions = NULL;
+
+		/* Check if xf86CollectOptions() has already been called */
+		if (((pEnt->index < 0) ||
+		     !xf86Screens[pEnt->index] ||
+		     !(configOptions = xf86Screens[pEnt->index]->options)) &&
+		    pEnt->device)
+			configOptions = pEnt->device->options;
+
+		if (configOptions) {
+			if (!(options = (OptionInfoPtr) xalloc(sizeof(INT10Options))))
+				return NULL;
+
+			(void) memcpy(options, INT10Options, sizeof(INT10Options));
+			xf86ProcessOptions(pScrn->scrnIndex, configOptions, options);
+		}
+	}
+	xfree(pEnt);
+
+	return options;
+}
+
+Bool int10skip(void *options)
+{
+	Bool noint10 = FALSE;
+
+	if (!options)
+		return FALSE;
+
+	xf86GetOptValBool(options, OPT_NOINT10, &noint10);
+	return noint10;
+}
+
+Bool int10_check_bios(int scrnIndex, int codeSeg, unsigned char *vbiosMem)
+{
+	int size;
+
+	if ((codeSeg & 0x1f) ||	/* Not 512-byte aligned otherwise */
+	    ((codeSeg << 4) < V_BIOS) || ((codeSeg << 4) >= SYS_SIZE))
+		return FALSE;
+
+	if (xf86IsPc98())
+		return FALSE;
+
+	if ((*vbiosMem != 0x55) || (*(vbiosMem + 1) != 0xAA) || !*(vbiosMem + 2))
+		return FALSE;
+
+	size = *(vbiosMem + 2) * 512;
+
+	if ((size + (codeSeg << 4)) > SYS_SIZE)
+		return FALSE;
+
+	if (bios_checksum(vbiosMem, size))
+		xf86DrvMsg(scrnIndex, X_WARNING, "Bad V_BIOS checksum\n");
+
+	return TRUE;
+}
+
+Bool initPrimary(void *options)
+{
+	Bool initPrimary = FALSE;
+
+	if (!options)
+		return FALSE;
+
+	xf86GetOptValBool(options, OPT_INIT_PRIMARY, &initPrimary);
+	return initPrimary;
+}
+
+void xf86int10ParseBiosLocation(void *options, xf86int10BiosLocationPtr bios)
+{
+	char *s;
+	char *p;
+	char *str = NULL;
+
+	if (options)
+		str = xf86GetOptValString(options, OPT_BIOS_LOCATION);
+
+	bios->bus = BUS_NONE;
+	if (!str)
+		return;
+
+	s = xstrdup(str);
+	p = strtok(s, ":");
+	if (xf86NameCmp(p, "pci"))
+		bios->bus = BUS_PCI;
+	else if (xf86NameCmp(p, "primary"))
+		bios->bus = BUS_ISA;
+
+	xfree(s);
+
+	if (bios->bus == BUS_NONE)
+		return;
+
+	s = xstrdup(str);
+	p = strchr(s, ':');
+
+	switch (bios->bus) {
+	case BUS_ISA:
+		if (p)
+			bios->location.legacy = atoi(++p);
+		else
+			bios->location.legacy = 0;
+		break;
+	case BUS_PCI:
+		if (p) {
+			bios->location.pci.bus = atoi(++p);
+			if ((p = strchr(p, ':'))) {
+				bios->location.pci.dev = atoi(++p);
+				if ((p = strchr(p, ':'))) {
+					bios->location.pci.func = atoi(++p);
+					break;
+				}
+			}
+		}
+		/* fall through */
+		bios->bus = BUS_NONE;
+		break;
+	default:
+		break;
+	}
+	xfree(s);
+}
+
+
+#endif
--- vgabios/sys_pci.h	(revision 0)
+++ vgabios/sys_pci.h	(revision 0)
@@ -0,0 +1,29 @@
+/*
+ * pci.h:
+ *
+ * Copyright (c) 2006 James McKenzie <james@fishsoup.dhs.org>,
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#ifndef __PCI_H__
+#define __PCI_H__
+
+unsigned char	conf1_read_8( int bus, int devfn, int off);
+unsigned short	conf1_read_16(int bus, int devfn, int off);
+unsigned long	conf1_read_32(int bus, int devfn, int off);
+void		conf1_write_8(int bus, int devfn, int off, unsigned char val);
+
+#endif /* __PCI_H__ */
--- vgabios/pci.h	(revision 0)
+++ vgabios/pci.h	(revision 0)
@@ -0,0 +1,2 @@
+void x_outb(u16 port, u8 val);
+#define outb x_outb
--- vgabios/helper_exec.c	(revision 0)
+++ vgabios/helper_exec.c	(revision 0)
@@ -0,0 +1,269 @@
+/* $XFree86: xc/programs/Xserver/hw/xfree86/int10/helper_exec.c,v 1.16 2001/04/30 14:34:57 tsi Exp $ */
+/*
+ *                   XFree86 int10 module
+ *   execute BIOS int 10h calls in x86 real mode environment
+ *                 Copyright 1999 Egbert Eich
+ *
+ *   Part of this is based on code taken from DOSEMU
+ *   (C) Copyright 1992, ..., 1999 the "DOSEMU-Development-Team"
+ */
+
+/*
+ * To debug port accesses define PRINT_PORT.
+ * Note! You also have to comment out ioperm()
+ * in xf86EnableIO(). Otherwise we won't trap
+ * on PIO.
+ */
+#include <x86emu.h>
+#include "test.h"
+#include "sys_io.h"
+//#include <sys/time.h>
+
+int port_rep_inb(u16 port, u32 base, int d_f, u32 count);
+u8 x_inb(u16 port);
+u16 x_inw(u16 port);
+void x_outb(u16 port, u8 val);
+void x_outw(u16 port, u16 val);
+u32 x_inl(u16 port);
+void x_outl(u16 port, u32 val);
+
+/* general software interrupt handler */
+u32 getIntVect(int num)
+{
+	return MEM_RW(num << 2) + (MEM_RW((num << 2) + 2) << 4);
+}
+
+void pushw(u16 val)
+{
+	X86_ESP -= 2;
+	MEM_WW(((u32) X86_SS << 4) + X86_SP, val);
+}
+
+int run_bios_int(int num)
+{
+	u32 eflags;
+
+	eflags = X86_EFLAGS;
+	pushw(eflags);
+	pushw(X86_CS);
+	pushw(X86_IP);
+	X86_CS = MEM_RW((num << 2) + 2);
+	X86_IP = MEM_RW(num << 2);
+
+	printf("%s: INT %x CS:IP = %x:%x\n", __FUNCTION__,
+	       num, MEM_RW((num << 2) + 2), MEM_RW(num << 2));
+
+	return 1;
+}
+
+int port_rep_inb(u16 port, u32 base, int d_f, u32 count)
+{
+	register int inc = d_f ? -1 : 1;
+	u32 dst = base;
+	while (count--) {
+		MEM_WB(dst, x_inb(port));
+		dst += inc;
+	}
+	return dst - base;
+}
+
+int port_rep_inw(u16 port, u32 base, int d_f, u32 count)
+{
+	register int inc = d_f ? -2 : 2;
+	u32 dst = base;
+	while (count--) {
+		MEM_WW(dst, x_inw(port));
+		dst += inc;
+	}
+	return dst - base;
+}
+
+int port_rep_inl(u16 port, u32 base, int d_f, u32 count)
+{
+	register int inc = d_f ? -4 : 4;
+	u32 dst = base;
+	while (count--) {
+		MEM_WL(dst, x_inl(port));
+		dst += inc;
+	}
+	return dst - base;
+}
+
+int port_rep_outb(u16 port, u32 base, int d_f, u32 count)
+{
+	register int inc = d_f ? -1 : 1;
+	u32 dst = base;
+	while (count--) {
+		x_outb(port, MEM_RB(dst));
+		dst += inc;
+	}
+	return dst - base;
+}
+
+int port_rep_outw(u16 port, u32 base, int d_f, u32 count)
+{
+	register int inc = d_f ? -2 : 2;
+	u32 dst = base;
+	while (count--) {
+		x_outw(port, MEM_RW(dst));
+		dst += inc;
+	}
+	return dst - base;
+}
+
+int port_rep_outl(u16 port, u32 base, int d_f, u32 count)
+{
+	register int inc = d_f ? -4 : 4;
+	u32 dst = base;
+	while (count--) {
+		x_outl(port, MEM_RL(dst));
+		dst += inc;
+	}
+	return dst - base;
+}
+
+u8 x_inb(u16 port)
+{
+	u8 val;
+
+	val = inb(port);
+
+	/*printf("inb(0x%04x) = 0x%02x\n", port, val);*/
+
+	return val;
+}
+
+u16 x_inw(u16 port)
+{
+	u16 val;
+
+	val = inw(port);
+
+	/*printf("inw(0x%04x) = 0x%04x\n", port, val);*/
+	return val;
+}
+
+u32 x_inl(u16 port)
+{
+	u32 val;
+
+	val = inl(port);
+
+	/*printf("inl(0x%04x) = 0x%08x\n", port, val);*/
+	return val;
+}
+
+void x_outb(u16 port, u8 val)
+{
+	/*printf("outb(0x%02x, 0x%04x)\n", val, port);*/
+	outb(val, port);
+}
+
+void x_outw(u16 port, u16 val)
+{
+	/*printf("outw(0x%04x, 0x%04x)\n", val, port);*/
+	outw(val, port);
+}
+
+void x_outl(u16 port, u32 val)
+{
+	/*printf("outl(0x%08x, 0x%04x)\n", val, port);*/
+	outl(val, port);
+}
+
+u8 Mem_rb(int addr)
+{
+	return (*current->mem->rb) (current, addr);
+}
+
+u16 Mem_rw(int addr)
+{
+	return (*current->mem->rw) (current, addr);
+}
+
+u32 Mem_rl(int addr)
+{
+	return (*current->mem->rl) (current, addr);
+}
+
+void Mem_wb(int addr, u8 val)
+{
+	(*current->mem->wb) (current, addr, val);
+}
+
+void Mem_ww(int addr, u16 val)
+{
+	(*current->mem->ww) (current, addr, val);
+}
+
+void Mem_wl(int addr, u32 val)
+{
+	(*current->mem->wl) (current, addr, val);
+}
+
+#if 0
+void getsecs(unsigned long *sec, unsigned long *usec)
+{
+	struct timeval tv;
+	gettimeofday(&tv, 0);
+	*sec = tv.tv_sec;
+	*usec = tv.tv_usec;
+}
+#endif
+
+#define TAG(Cfg1Addr) (Cfg1Addr & 0xffff00)
+#define OFFSET(Cfg1Addr) (Cfg1Addr & 0xff)
+
+u8 bios_checksum(u8 * start, int size)
+{
+	u8 sum = 0;
+
+	while (size-- > 0)
+		sum += *start++;
+	return sum;
+}
+
+/*
+ * Lock/Unlock legacy VGA. Some Bioses try to be very clever and make
+ * an attempt to detect a legacy ISA card. If they find one they might
+ * act very strange: for example they might configure the card as a
+ * monochrome card. This might cause some drivers to choke.
+ * To avoid this we attempt legacy VGA by writing to all know VGA
+ * disable registers before we call the BIOS initialization and
+ * restore the original values afterwards. In beween we hold our
+ * breath. To get to a (possibly exising) ISA card need to disable
+ * our current PCI card.
+ */
+/*
+ * This is just for booting: we just want to catch pure
+ * legacy vga therefore we don't worry about mmio etc.
+ * This stuff should really go into vgaHW.c. However then
+ * the driver would have to load the vga-module prior to
+ * doing int10.
+ */
+/*void
+LockLegacyVGA(int screenIndex,legacyVGAPtr vga)
+{
+    xf86SetCurrentAccess(FALSE, xf86Screens[screenIndex]);
+    vga->save_msr = inb(0x3CC);
+    vga->save_vse = inb(0x3C3);
+    vga->save_46e8 = inb(0x46e8);
+    vga->save_pos102 = inb(0x102);
+    outb(0x3C2, ~(u8)0x03 & vga->save_msr);
+    outb(0x3C3, ~(u8)0x01 & vga->save_vse);
+    outb(0x46e8, ~(u8)0x08 & vga->save_46e8);
+    outb(0x102, ~(u8)0x01 & vga->save_pos102);
+    xf86SetCurrentAccess(TRUE, xf86Screens[screenIndex]);
+}
+
+void
+UnlockLegacyVGA(int screenIndex, legacyVGAPtr vga)
+{
+    xf86SetCurrentAccess(FALSE, xf86Screens[screenIndex]);
+    outb(0x102, vga->save_pos102);
+    outb(0x46e8, vga->save_46e8);
+    outb(0x3C3, vga->save_vse);
+    outb(0x3C2, vga->save_msr);
+    xf86SetCurrentAccess(TRUE, xf86Screens[screenIndex]);
+}
+*/
--- vgabios/test.h	(revision 0)
+++ vgabios/test.h	(revision 0)
@@ -0,0 +1,89 @@
+/* $XFree86: xc/programs/Xserver/hw/xfree86/int10/xf86x86emu.h,v 1.2 2001/01/06 20:19:13 tsi Exp $ */
+/*
+ *                   XFree86 int10 module
+ *   execute BIOS int 10h calls in x86 real mode environment
+ *                 Copyright 1999 Egbert Eich
+ */
+#ifndef XF86X86EMU_H_
+#define XF86X86EMU_H_
+#include <x86emu.h>
+
+#define M _X86EMU_env
+
+#define X86_EAX M.x86.R_EAX
+#define X86_EBX M.x86.R_EBX
+#define X86_ECX M.x86.R_ECX
+#define X86_EDX M.x86.R_EDX
+#define X86_ESI M.x86.R_ESI
+#define X86_EDI M.x86.R_EDI
+#define X86_EBP M.x86.R_EBP
+#define X86_EIP M.x86.R_EIP
+#define X86_ESP M.x86.R_ESP
+#define X86_EFLAGS M.x86.R_EFLG
+
+#define X86_FLAGS M.x86.R_FLG
+#define X86_AX M.x86.R_AX
+#define X86_BX M.x86.R_BX
+#define X86_CX M.x86.R_CX
+#define X86_DX M.x86.R_DX
+#define X86_SI M.x86.R_SI
+#define X86_DI M.x86.R_DI
+#define X86_BP M.x86.R_BP
+#define X86_IP M.x86.R_IP
+#define X86_SP M.x86.R_SP
+#define X86_CS M.x86.R_CS
+#define X86_DS M.x86.R_DS
+#define X86_ES M.x86.R_ES
+#define X86_SS M.x86.R_SS
+#define X86_FS M.x86.R_FS
+#define X86_GS M.x86.R_GS
+
+#define X86_AL M.x86.R_AL
+#define X86_BL M.x86.R_BL
+#define X86_CL M.x86.R_CL
+#define X86_DL M.x86.R_DL
+
+#define X86_AH M.x86.R_AH
+#define X86_BH M.x86.R_BH
+#define X86_CH M.x86.R_CH
+#define X86_DH M.x86.R_DH
+
+
+/* int10 info structure */
+typedef struct {
+	u16 BIOSseg;
+	u16 inb40time;
+	struct _mem *mem;
+	int num;
+	int ax;
+	int bx;
+	int cx;
+	int dx;
+	int si;
+	int di;
+	int es;
+	int bp;
+	int flags;
+	int stackseg;
+} _ptr, *ptr;
+
+typedef struct _mem {
+	u8(*rb) (ptr, int);
+	u16(*rw) (ptr, int);
+	u32(*rl) (ptr, int);
+	void (*wb) (ptr, int, u8);
+	void (*ww) (ptr, int, u16);
+	void (*wl) (ptr, int, u32);
+} mem;
+
+#define MEM_WB(where, what) wrb(where,what)
+#define MEM_WW(where, what) wrw(where, what)
+#define MEM_WL(where, what) wrl(where, what)
+
+#define MEM_RB(where) rdb(where)
+#define MEM_RW(where) rdw(where)
+#define MEM_RL(where) rdl(where)
+
+extern ptr current;
+
+#endif
--- vgabios/inte6.c	(revision 0)
+++ vgabios/inte6.c	(revision 0)
@@ -0,0 +1,18 @@
+#include <stdio.h>
+
+int intE6_handler()
+{
+#if 0
+	pciVideoPtr pvp;
+
+	if ((pvp = xf86GetPciInfoForEntity(pInt->entityIndex)))
+		X86_AX = (pvp->bus << 8) | (pvp->device << 3) | (pvp->func & 0x7);
+	pushw(X86_CS);
+	pushw(X86_IP);
+	X86_CS = pInt->BIOSseg;
+	X86_EIP = 0x0003;
+	X86_ES = 0;		/* standard pc es */
+#endif
+	printf("intE6 not supported right now.\n");
+	return 1;
+}
--- vgabios/vgabios.c	(revision 0)
+++ vgabios/vgabios.c	(revision 0)
@@ -0,0 +1,285 @@
+#include "../types.h"
+#include "../utils.h"
+#include "../linux_code.h"
+#include "sys_pci.h"
+
+#include <x86emu.h>
+#include "test.h"
+
+// interrupt handlers
+int int15_handler(void);
+int int16_handler(void);
+int int1A_handler(void);
+int int42_handler(void);
+int intE6_handler(void);
+// int10 info structure
+_ptr p;
+ptr current = 0;
+unsigned char biosmem[1024 * 1024];
+
+int verbose = 0;
+// helper_exec.c
+u32	getIntVect(int num);
+void	pushw(u16 val);
+int	run_bios_int(int num);
+u8	x_inb(u16 port);
+u16	x_inw(u16 port);
+void	x_outb(u16 port, u8 val);
+void	x_outw(u16 port, u16 val);
+u32	x_inl(u16 port);
+void	x_outl(u16 port, u32 val);
+
+X86EMU_pioFuncs myfuncs = {
+	x_inb, x_inw, x_inl,
+	x_outb, x_outw, x_outl
+};
+
+//
+void X86EMU_setMemBase(void *base, size_t size);
+void X86EMU_setabseg(void *abseg);
+
+
+//
+extern int	safe_to_use_bios;
+extern int	safe_to_use_vesa;
+
+#define bios_tbl_len 258
+// real_memory is used internally by vbetool.c and thunk.c
+//extern	uint8_t	*real_memory;
+
+void	copy_memory_to_system(uint8_t *addr);
+void	vga_post(uint8_t *bios_addr, unsigned int pci_id);
+void	do_int(int num);
+void	bios_write_char(char *s);
+
+/*---------------------------------------------------------------------------*/
+void
+copy_memory_to_system(uint8_t *addr)
+{
+	//print("ATV: Map bios RAM memory read/write\n");
+	// Intel 82945G Host bridge
+	// 0x90-0x96 -- programmable attribute map (PAM0-PAM6)
+	// 0x97 -- legacy access control (LAC)
+	conf1_write_8(0, 0, 0x90, 0x30); // PAM0 - 0xF0000-0xFFFFF w/r -> dram
+	conf1_write_8(0, 0, 0x91, 0x33); // PAM1 - 0xC0000-0xC3FFF and 0xC4000-0xC7FFF  w/r -> dram
+	conf1_write_8(0, 0, 0x92, 0x33); // PAM2 - 0xC8000-0xCBFFF and 0xCC000-0xCFFFF  w/r -> dram
+	conf1_write_8(0, 0, 0x93, 0x33); // PAM3 - 0xD0000-0xD3FFF and 0xD4000-0xD7FFF  w/r -> dram
+	conf1_write_8(0, 0, 0x94, 0x33); // PAM4 - 0xD8000-0xDBFFF and 0xDC000-0xDFFFF  w/r -> dram
+	conf1_write_8(0, 0, 0x95, 0x33); // PAM5 - 0xE0000-0xE3FFF and 0xE4000-0xE7FFF  w/r -> dram
+	conf1_write_8(0, 0, 0x96, 0x33); // PAM6 - 0xE8000-0xEBFFF and 0xEC000-0xEFFFF  w/r -> dram
+	conf1_write_8(0, 0, 0x97, 0x00); // LAC - 15MB to 16MB memory hole disabled, MDA and VGA references routed to DMI
+
+	//print("ATV: Copy bios rom code into place\n");
+	/*Interrupt table */
+	memcpy( (void*) (0x0), addr, 0x400);
+	/*BIOS table */
+	memcpy( (void*) (0x400), addr + 0x400, bios_tbl_len);
+	/*Video rom */
+	memcpy( (void*) (0xc0000), addr + 0xc0000, 0x20000);
+	/*System rom */
+	memcpy( (void*) (0xe0000), addr + 0xe0000, 0x20000);
+
+	//print("ATV: Map bios RAM location readonly\n");
+	conf1_write_8( 0, 0, 0x90, 0x10); // PAM0 - 0xF0000-0xFFFFF r -> dram, w -> DMI
+	conf1_write_8( 0, 0, 0x91, 0x11); // PAM1 - 0xC0000-0xC3FFF and 0xC4000-0xC7FFF  r -> dram, w -> DMI
+	conf1_write_8( 0, 0, 0x92, 0x11); // PAM2 - 0xC8000-0xCBFFF and 0xCC000-0xCFFFF  r -> dram, w -> DMI
+	conf1_write_8( 0, 0, 0x93, 0x11); // PAM3 - 0xD0000-0xD3FFF and 0xD4000-0xD7FFF  r -> dram, w -> DMI
+	conf1_write_8( 0, 0, 0x94, 0x11); // PAM4 - 0xD8000-0xDBFFF and 0xDC000-0xDFFFF  r -> dram, w -> DMI
+}
+
+/*---------------------------------------------------------------------------*/
+void
+vga_init(boot_params_t *bp, uint8_t *bios_addr)
+{
+	unsigned int pci_id;
+	
+	//real_memory = bios_addr;
+
+	// Intel 82945G Host bridge
+	// 0x54 -- Device Enable (DEVEN)
+	// DEVEN - 0x83 for AppleTV (both internal GMs are disabled, PCI express port enabled)
+	conf1_write_8(0, 0, 0x54, 0x83);
+
+	//LRMI_init();
+
+	// Stop using "print" with the vesa linear buffer from EFI from now on
+	//safe_to_use_vesa = 0;
+	
+	// MacMini (lspci)
+	// 00:02.00 VGA compatible controller: Intel Corporation Mobile 945GM/GMS, 943/940GML Express Integrated Graphics Controller (rev 03)
+	//pci_id = ( (1 << 8) | (0 << 3) | (0 & 0x7) ) & 0x0000FFFF;
+	// iMac 20" 
+	// 01:00.0 VGA compatible controller: ATI Technologies Inc Unknown device 71c5
+	// iMac 24" 
+	// 01:00.0 VGA compatible controller: ATI Technologies Inc Unknown device 9583
+	// AppleTV (lspci)
+	// 01:00.00 VGA compatible controller: nVidia Corporation Quadro NVS 110M / GeForce Go 7300 (rev a1)
+	pci_id = ( (1 << 8) + (0 << 3) + (0 & 0x7) ) & 0x0000FFFF;
+
+	vga_post(bios_addr, pci_id);
+	
+	//do_real_post(pci_id);
+	//do_set_mode(3, 1);
+
+	// Copy the roms from our emulator into the system */
+	copy_memory_to_system(bios_addr);
+	
+	//print("ATV: Map bios RAM location readonly\n");
+	conf1_write_8( 0, 0, 0x90, 0x10); // PAM0 - 0xF0000-0xFFFFF r -> dram, w -> DMI
+	conf1_write_8( 0, 0, 0x91, 0x11); // PAM1 - 0xC0000-0xC3FFF and 0xC4000-0xC7FFF  r -> dram, w -> DMI
+	conf1_write_8( 0, 0, 0x92, 0x11); // PAM2 - 0xC8000-0xCBFFF and 0xCC000-0xCFFFF  r -> dram, w -> DMI
+	conf1_write_8( 0, 0, 0x93, 0x11); // PAM3 - 0xD0000-0xD3FFF and 0xD4000-0xD7FFF  r -> dram, w -> DMI
+	conf1_write_8( 0, 0, 0x94, 0x11); // PAM4 - 0xD8000-0xDBFFF and 0xDC000-0xDFFFF  r -> dram, w -> DMI
+
+	//bios_set_active_page(0x0);
+	//bios_move_cursor(0, 0);
+
+	// Call into the real mode bios to write to the screen now */
+	safe_to_use_bios = 1;
+	/*
+	// setup Linux video boot params
+	{
+		int have_vga, video_ega_bx = 0;
+		int cursor_pos = 0;
+		int video_page = 0;
+		int video_mode = 0;
+		int font_points = 0;
+		int video_cols = 0;
+		int video_lines = 0;
+
+		//linux_basic_detect(&have_vga, &video_ega_bx);
+		//linux_mode_params(&cursor_pos, &video_page, &video_mode, &font_points,
+		//	       &video_cols, &video_lines);
+
+		have_vga = 1;
+		
+		bp->s.orig_x = cursor_pos & 0xff;
+		bp->s.orig_y = cursor_pos >> 8;
+		bp->s.orig_video_page = video_page;
+		bp->s.orig_video_mode = video_mode;
+		bp->s.orig_video_cols = video_cols;
+		bp->s.orig_video_rows = video_lines + 1;
+
+		bp->s.orig_ega_bx = video_ega_bx;
+		bp->s.is_vga = have_vga;
+		bp->s.orig_video_points = font_points;
+	}
+	*/
+}
+
+/*---------------------------------------------------------------------------*/
+void
+vga_post(uint8_t *bios_addr, unsigned int pci_id)
+{
+	int	i;
+	void	*abseg = 0;
+	unsigned short initialip = 0xc000;
+	unsigned short initialcs = 0x0003;
+	unsigned short devfn = pci_id;
+	//
+	X86EMU_intrFuncs intFuncs[256];
+
+	current = &p;
+	//
+	X86EMU_setMemBase(bios_addr, 1024*1024);
+	X86EMU_setabseg(abseg);
+	X86EMU_setupPioFuncs(&myfuncs);
+
+	// Setting up interrupt environment.
+	for (i = 0; i < 256; i++) {
+		intFuncs[i] = do_int;
+	}
+	X86EMU_setupIntrFuncs(intFuncs);
+	
+	current->ax = devfn;
+	current->dx = 0x80;
+
+	// fake bios (wrb -> write byte to emulator memory)
+	char *date = "01/01/99";
+	for (i = i; date[i]; i++) {
+		wrb(0xffff5 + i, date[i]);
+	}
+	wrb(0xffff7, '/');
+	wrb(0xffffa, '/');
+
+	/* cpu setup */
+	X86_AX = devfn;
+	X86_DX = 0x80;
+	X86_EIP = initialip;
+	X86_CS = initialcs;
+
+	/* Initialize stack and data segment */
+	X86_SS = 0x0030;
+	X86_DS = 0x0040;
+	X86_SP = 0xfffe;
+	/* We need a sane way to return from bios
+	 * execution. A hlt instruction and a pointer
+	 * to it, both kept on the stack, will do.
+	 */
+	pushw(0xf4f4);		/* hlt; hlt */
+	pushw(X86_SS);
+	pushw(X86_SP + 2);
+
+	X86_ES = 0x0000;
+
+	if (0) {
+		//printf("Switching to single step mode.\n");
+		//X86EMU_trace_on();
+	}
+	if (0) {
+		//X86EMU_set_debug(debugflag);
+	}
+	X86EMU_exec();
+}
+/*---------------------------------------------------------------------------*/
+void	bios_write_char(char *s)
+{
+
+}
+
+/*---------------------------------------------------------------------------*/
+/* Interrupt multiplexer */
+void do_int(int num)
+{
+	int ret = 0;
+
+	printf("int%x vector at %x\n", num, getIntVect(num));
+
+	/* This is a pInt leftover */
+	current->num = num;
+
+	switch (num) {
+	case 0x10:
+	case 0x42:
+	case 0x6D:
+
+		if (getIntVect(num) == 0xFF065) {
+			ret = int42_handler();
+		}
+		break;
+	case 0x15:
+		ret = int15_handler();
+		break;
+	case 0x16:
+		ret = int16_handler();
+		break;
+	case 0x1A:
+		//ret = int1A_handler();
+		break;
+	case 0xe6:
+		ret = intE6_handler();
+		break;
+	default:
+		break;
+	}
+
+	if (!ret)
+		ret = run_bios_int(num);
+
+	if (!ret) {
+		printf("\nint%x: not implemented\n", num);
+		//x86emu_dump_xregs();
+	}
+}
+
+
--- vgabios/int10.c	(revision 0)
+++ vgabios/int10.c	(revision 0)
@@ -0,0 +1,478 @@
+#include <stdio.h>
+#include "test.h"
+#include "pci.h"
+
+void x86emu_dump_xregs(void);
+extern ptr current;
+extern int verbose;
+
+
+#ifndef _PC
+/*
+ * This is derived from a number of PC system BIOS'es.  The intent here is to
+ * provide very primitive video support, before an EGA/VGA BIOS installs its
+ * own interrupt vector.  Here, "Ignored" calls should remain so.  "Not
+ * Implemented" denotes functionality that can be implemented should the need
+ * arise.  What are "Not Implemented" throughout are video memory accesses.
+ * Also, very little input validity checking is done here.
+ */
+int int42_handler()
+{
+#if 0
+	if (verbose && X86_AH != 0x0e) {
+		printf("int%x\n", current->num);
+		x86emu_dump_xregs();
+	}
+
+	switch (X86_AH) {
+	case 0x00:
+		/* Set Video Mode                                     */
+		/* Enter:  AL = video mode number                     */
+		/* Leave:  Nothing                                    */
+		/* Implemented (except for clearing the screen)       */
+		{		/* Localise */
+			int i;
+			u16 ioport, int1d, regvals, tmp;
+			u8 mode, cgamode, cgacolour;
+
+			/*
+			 * Ignore all mode numbers but 0x00-0x13.  Some systems also ignore
+			 * 0x0B and 0x0C, but don't do that here.
+			 */
+			if (X86_AL > 0x13)
+				break;
+
+			/*
+			 * You didn't think that was really the mode set, did you?  There
+			 * are only so many slots in the video parameter table...
+			 */
+			mode = X86_AL;
+			ioport = 0x03D4;
+			switch (MEM_RB(0x0410) & 0x30) {
+			case 0x30:	/* MDA */
+				mode = 0x07;	/* Force mode to 0x07 */
+				ioport = 0x03B4;
+				break;
+			case 0x10:	/* CGA 40x25 */
+				if (mode >= 0x07)
+					mode = 0x01;
+				break;
+			case 0x20:	/* CGA 80x25 (MCGA?) */
+				if (mode >= 0x07)
+					mode = 0x03;
+				break;
+			case 0x00:	/* EGA/VGA */
+				if (mode >= 0x07)	/* Don't try MDA timings */
+					mode = 0x01;	/* !?!?! */
+				break;
+			}
+
+			/* Locate data in video parameter table */
+			int1d = MEM_RW(0x1d << 2);
+			regvals = ((mode >> 1) << 4) + int1d;
+			cgacolour = 0x30;
+			if (mode == 0x06) {
+				regvals -= 0x10;
+				cgacolour = 0x3F;
+			}
+
+	    /** Update BIOS Data Area **/
+
+			/* Video mode */
+			MEM_WB(0x0449, mode);
+
+			/* Columns */
+			tmp = MEM_RB(mode + int1d + 0x48);
+			MEM_WW(0x044A, tmp);
+
+			/* Page length */
+			tmp = MEM_RW((mode & 0x06) + int1d + 0x40);
+			MEM_WW(0x044C, tmp);
+
+			/* Start Address */
+			MEM_WW(0x044E, 0);
+
+			/* Cursor positions, one for each display page */
+			for (i = 0x0450; i < 0x0460; i += 2)
+				MEM_WW(i, 0);
+
+			/* Cursor start & end scanlines */
+			tmp = MEM_RB(regvals + 0x0B);
+			MEM_WB(0x0460, tmp);
+			tmp = MEM_RB(regvals + 0x0A);
+			MEM_WB(0x0461, tmp);
+
+			/* Current display page number */
+			MEM_WB(0x0462, 0);
+
+			/* CRTC I/O address */
+			MEM_WW(0x0463, ioport);
+
+			/* CGA Mode register value */
+			cgamode = MEM_RB(mode + int1d + 0x50);
+			MEM_WB(0x0465, cgamode);
+
+			/* CGA Colour register value */
+			MEM_WB(0x0466, cgacolour);
+
+			/* Rows */
+			MEM_WB(0x0484, (25 - 1));
+
+			/* Programme the mode */
+			outb(ioport + 4, cgamode & 0x37);	/* Turn off screen */
+			for (i = 0; i < 0x10; i++) {
+				tmp = MEM_RB(regvals + i);
+				outb(ioport, i);
+				outb(ioport + 1, tmp);
+			}
+			outb(ioport + 5, cgacolour);	/* Select colour mode */
+			outb(ioport + 4, cgamode);	/* Turn on screen */
+		}
+		break;
+
+	case 0x01:
+		/* Set Cursor Type                                    */
+		/* Enter:  CH = starting line for cursor              */
+		/*         CL = ending line for cursor                */
+		/* Leave:  Nothing                                    */
+		/* Implemented                                        */
+		{		/* Localise */
+			u16 ioport = MEM_RW(0x0463);
+
+			MEM_WB(0x0460, X86_CL);
+			MEM_WB(0x0461, X86_CH);
+
+			outb(ioport, 0x0A);
+			outb(ioport + 1, X86_CH);
+			outb(ioport, 0x0B);
+			outb(ioport + 1, X86_CL);
+		}
+		break;
+
+	case 0x02:
+		/* Set Cursor Position                                */
+		/* Enter:  BH = display page number                   */
+		/*         DH = row                                   */
+		/*         DL = column                                */
+		/* Leave:  Nothing                                    */
+		/* Implemented                                        */
+		{		/* Localise */
+			u16 offset, ioport;
+
+			MEM_WB((X86_BH << 1) + 0x0450, X86_DL);
+			MEM_WB((X86_BH << 1) + 0x0451, X86_DH);
+
+			if (X86_BH != MEM_RB(0x0462))
+				break;
+
+			offset = (X86_DH * MEM_RW(0x044A)) + X86_DL;
+			offset += MEM_RW(0x044E) << 1;
+
+			ioport = MEM_RW(0x0463);
+			outb(ioport, 0x0E);
+			outb(ioport + 1, offset >> 8);
+			outb(ioport, 0x0F);
+			outb(ioport + 1, offset & 0xFF);
+		}
+		break;
+
+	case 0x03:
+		/* Get Cursor Position                                */
+		/* Enter:  BH = display page number                   */
+		/* Leave:  CH = starting line for cursor              */
+		/*         CL = ending line for cursor                */
+		/*         DH = row                                   */
+		/*         DL = column                                */
+		/* Implemented                                        */
+		{		/* Localise */
+			X86_CL = MEM_RB(0x0460);
+			X86_CH = MEM_RB(0x0461);
+			X86_DL = MEM_RB((X86_BH << 1) + 0x0450);
+			X86_DH = MEM_RB((X86_BH << 1) + 0x0451);
+		}
+		break;
+
+	case 0x04:
+		/* Get Light Pen Position                             */
+		/* Enter:  Nothing                                    */
+		/* Leave:  AH = 0x01 (down/triggered) or 0x00 (not)   */
+		/*         BX = pixel column                          */
+		/*         CX = pixel row                             */
+		/*         DH = character row                         */
+		/*         DL = character column                      */
+		/* Not Implemented                                    */
+		{		/* Localise */
+			printf("int%x - Get Light Pen Position. "
+			       "Function not implemented.\n", current->num);
+			x86emu_dump_xregs();
+			X86_AH = X86_BX = X86_CX = X86_DX = 0;
+		}
+		break;
+
+	case 0x05:
+		/* Set Display Page                                   */
+		/* Enter:  AL = display page number                   */
+		/* Leave:  Nothing                                    */
+		/* Implemented                                        */
+		{		/* Localise */
+			u16 start, ioport = MEM_RW(0x0463);
+			u8 x, y;
+
+			/* Calculate new start address */
+			MEM_WB(0x0462, X86_AL);
+			start = X86_AL * MEM_RW(0x044C);
+			MEM_WW(0x044E, start);
+			start <<= 1;
+
+			/* Update start address */
+			outb(ioport, 0x0C);
+			outb(ioport + 1, start >> 8);
+			outb(ioport, 0x0D);
+			outb(ioport + 1, start & 0xFF);
+
+			/* Switch cursor position */
+			y = MEM_RB((X86_AL << 1) + 0x0450);
+			x = MEM_RB((X86_AL << 1) + 0x0451);
+			start += (y * MEM_RW(0x044A)) + x;
+
+			/* Update cursor position */
+			outb(ioport, 0x0E);
+			outb(ioport + 1, start >> 8);
+			outb(ioport, 0x0F);
+			outb(ioport + 1, start & 0xFF);
+		}
+		break;
+
+	case 0x06:
+		/* Initialise or Scroll Window Up                     */
+		/* Enter:  AL = lines to scroll up                    */
+		/*         BH = attribute for blank                   */
+		/*         CH = upper y of window                     */
+		/*         CL = left x of window                      */
+		/*         DH = lower y of window                     */
+		/*         DL = right x of window                     */
+		/* Leave:  Nothing                                    */
+		/* Not Implemented                                    */
+		{		/* Localise */
+			printf("int%x: Initialise or Scroll Window Up - "
+			       "Function not implemented.\n", current->num);
+			x86emu_dump_xregs();
+		}
+		break;
+
+	case 0x07:
+		/* Initialise or Scroll Window Down                   */
+		/* Enter:  AL = lines to scroll down                  */
+		/*         BH = attribute for blank                   */
+		/*         CH = upper y of window                     */
+		/*         CL = left x of window                      */
+		/*         DH = lower y of window                     */
+		/*         DL = right x of window                     */
+		/* Leave:  Nothing                                    */
+		/* Not Implemented                                    */
+		{		/* Localise */
+			printf("int%x: Initialise or Scroll Window Down - "
+			       "Function not implemented.\n", current->num);
+			x86emu_dump_xregs();
+
+		}
+		break;
+
+	case 0x08:
+		/* Read Character and Attribute at Cursor             */
+		/* Enter:  BH = display page number                   */
+		/* Leave:  AH = attribute                             */
+		/*         AL = character                             */
+		/* Not Implemented                                    */
+		{		/* Localise */
+			printf
+			    ("int%x: Read Character and Attribute at Cursor - "
+			     "Function not implemented.\n", current->num);
+			x86emu_dump_xregs();
+
+			X86_AX = 0;
+		}
+		break;
+
+	case 0x09:
+		/* Write Character and Attribute at Cursor            */
+		/* Enter:  AL = character                             */
+		/*         BH = display page number                   */
+		/*         BL = attribute (text) or colour (graphics) */
+		/*         CX = replication count                     */
+		/* Leave:  Nothing                                    */
+		/* Not Implemented                                    */
+		{		/* Localise */
+			printf
+			    ("int%x: Write Character and Attribute at Cursor - "
+			     "Function not implemented.\n", current->num);
+			x86emu_dump_xregs();
+
+		}
+		break;
+
+	case 0x0a:
+		/* Write Character at Cursor                          */
+		/* Enter:  AL = character                             */
+		/*         BH = display page number                   */
+		/*         BL = colour                                */
+		/*         CX = replication count                     */
+		/* Leave:  Nothing                                    */
+		/* Not Implemented                                    */
+		{		/* Localise */
+			printf("int%x: Write Character at Cursor - "
+			       "Function not implemented.\n", current->num);
+			x86emu_dump_xregs();
+
+		}
+		break;
+
+	case 0x0b:
+		/* Set Palette, Background or Border                  */
+		/* Enter:  BH = 0x00 or 0x01                          */
+		/*         BL = colour or palette (respectively)      */
+		/* Leave:  Nothing                                    */
+		/* Implemented                                        */
+		{		/* Localise */
+			u16 ioport = MEM_RW(0x0463) + 5;
+			u8 cgacolour = MEM_RB(0x0466);
+
+			if (X86_BH) {
+				cgacolour &= 0xDF;
+				cgacolour |= (X86_BL & 0x01) << 5;
+			} else {
+				cgacolour &= 0xE0;
+				cgacolour |= X86_BL & 0x1F;
+			}
+
+			MEM_WB(0x0466, cgacolour);
+			outb(ioport, cgacolour);
+		}
+		break;
+
+	case 0x0c:
+		/* Write Graphics Pixel                               */
+		/* Enter:  AL = pixel value                           */
+		/*         BH = display page number                   */
+		/*         CX = column                                */
+		/*         DX = row                                   */
+		/* Leave:  Nothing                                    */
+		/* Not Implemented                                    */
+		{		/* Localise */
+			printf("int%x: Write Graphics Pixel - "
+			       "Function not implemented.\n", current->num);
+			x86emu_dump_xregs();
+
+		}
+		break;
+
+	case 0x0d:
+		/* Read Graphics Pixel                                */
+		/* Enter:  BH = display page number                   */
+		/*         CX = column                                */
+		/*         DX = row                                   */
+		/* Leave:  AL = pixel value                           */
+		/* Not Implemented                                    */
+		{		/* Localise */
+			printf("int%x: Write Graphics Pixel - "
+			       "Function not implemented.\n", current->num);
+			x86emu_dump_xregs();
+
+			X86_AL = 0;
+
+		}
+		break;
+
+	case 0x0e:
+		/* Write Character in Teletype Mode                   */
+		/* Enter:  AL = character                             */
+		/*         BH = display page number                   */
+		/*         BL = foreground colour                     */
+		/* Leave:  Nothing                                    */
+		/* Not Implemented                                    */
+		/* WARNING:  Emulation of BEL characters will require */
+		/*           emulation of RTC and PC speaker I/O.     */
+		/*           Also, this recurses through int 0x10     */
+		/*           which might or might not have been       */
+		/*           installed yet.                           */
+		{		/* Localise */
+#ifdef PARANOID
+			printf("int%x: Write Character in Teletype Mode - "
+			       "Function not implemented.\n", current->num);
+			x86emu_dump_xregs();
+#endif
+			printf("%c", X86_AL);
+		}
+		break;
+
+	case 0x0f:
+		/* Get Video Mode                                     */
+		/* Enter:  Nothing                                    */
+		/* Leave:  AH = number of columns                     */
+		/*         AL = video mode number                     */
+		/*         BH = display page number                   */
+		/* Implemented                                        */
+		{		/* Localise */
+			X86_AH = MEM_RW(0x044A);
+			X86_AL = MEM_RB(0x0449);
+			X86_BH = MEM_RB(0x0462);
+		}
+		break;
+
+	case 0x10:
+		/* Colour Control (subfunction in AL)                 */
+		/* Enter:  Various                                    */
+		/* Leave:  Various                                    */
+		/* Ignored                                            */
+		break;
+
+	case 0x11:
+		/* Font Control (subfunction in AL)                   */
+		/* Enter:  Various                                    */
+		/* Leave:  Various                                    */
+		/* Ignored                                            */
+		break;
+
+	case 0x12:
+		/* Miscellaneous (subfunction in BL)                  */
+		/* Enter:  Various                                    */
+		/* Leave:  Various                                    */
+		/* Ignored.  Previous code here optionally allowed    */
+		/* the enabling and disabling of VGA, but no system   */
+		/* BIOS I've come across actually implements it.      */
+		break;
+
+	case 0x13:
+		/* Write String in Teletype Mode                      */
+		/* Enter:  AL = write mode                            */
+		/*         BL = attribute (if (AL & 0x02) == 0)       */
+		/*         CX = string length                         */
+		/*         DH = row                                   */
+		/*         DL = column                                */
+		/*         ES:BP = string segment:offset              */
+		/* Leave:  Nothing                                    */
+		/* Not Implemented                                    */
+		/* WARNING:  Emulation of BEL characters will require */
+		/*           emulation of RTC and PC speaker I/O.     */
+		/*           Also, this recurses through int 0x10     */
+		/*           which might or might not have been       */
+		/*           installed yet.                           */
+		{		/* Localise */
+			printf("int%x: Write String in Teletype Mode - "
+			       "Function not implemented.\n", current->num);
+			x86emu_dump_xregs();
+
+		}
+		break;
+
+	default:
+		/* Various extensions                                 */
+		/* Enter:  Various                                    */
+		/* Leave:  Various                                    */
+		/* Ignored                                            */
+		break;
+	}
+#endif
+	return 1;
+}
+#endif
--- vgabios/Makefile	(revision 0)
+++ vgabios/Makefile	(revision 0)
@@ -0,0 +1,35 @@
+TARGETLIB = vgabios.a
+
+CC       =  gcc
+CFLAGS   =  -Wall -O2 -g -arch i386 -static -nostdlib\
+		-DNULL=0 \
+		-Dprintf=print
+		-DLIBPCI_MAJOR_VERSION=3  \
+		-DLIBPCI_MINOR_VERSION=0  \
+		-DLIBPCI_MICRO_VERSION=0
+
+INTOBJS	=  int10.o int15.o int16.o inte6.o
+#INTOBJS=  int10.o int15.o int16.o int1a.o inte6.o
+OBJECTS	=  vgabios.o sys_pci.o helper_exec.o helper_mem.o $(INTOBJS)
+#OBJECTS += pci-userspace.o
+
+LIBS	=  x86emu/src/libx86emu.a
+
+INCS	= -I. -Ix86emu/include
+
+all: $(TARGETLIB)
+
+$(TARGETLIB): $(OBJECTS) $(LIBS)
+	ar rv $(TARGETLIB) $(OBJECTS) $(LIBS)
+
+helper_exec.o: helper_exec.c test.h
+
+x86emu/src/libx86emu.a:
+	$(MAKE) -C x86emu/src/ -f make.darwin
+
+clean:
+	$(MAKE) -C x86emu/src/ -f make.darwin clean
+	$(RM) -f $(TARGET) $(OBJECTS)
+
+%.o: %.c 
+	$(CC) $(INCS) $(CFLAGS) -c $< -o $@
--- vgabios/testbios.c	(revision 0)
+++ vgabios/testbios.c	(revision 0)
@@ -0,0 +1,396 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/io.h>
+#include <sys/mman.h>
+#include <fcntl.h>
+#include <getopt.h>
+#include <string.h>
+
+#define die(x) { perror(x); exit(1); }
+#define warn(x) { perror(x);  }
+
+#include <x86emu.h>
+#include "test.h"
+#include "pci-userspace.h"
+
+void x86emu_dump_xregs(void);
+int int15_handler(void);
+int int16_handler(void);
+int int1A_handler(void);
+#ifndef _PC
+int int42_handler(void);
+#endif
+int intE6_handler(void);
+
+void pushw(u16 val);
+
+unsigned short get_device(char *arg_val);
+
+extern int teststart, testend;
+
+// int10 info structure
+_ptr p;
+ptr current = 0;
+
+unsigned char biosmem[1024 * 1024];
+
+int verbose = 0;
+
+
+/* Interrupt multiplexer */
+
+void do_int(int num)
+{
+	int ret = 0;
+
+	printf("int%x vector at %x\n", num, getIntVect(num));
+
+	/* This is a pInt leftover */
+	current->num = num;
+
+	switch (num) {
+#ifndef _PC
+	case 0x10:
+	case 0x42:
+	case 0x6D:
+
+		if (getIntVect(num) == 0xFF065) {
+			ret = int42_handler();
+		}
+		break;
+#endif
+	case 0x15:
+		ret = int15_handler();
+		break;
+	case 0x16:
+		ret = int16_handler();
+		break;
+	case 0x1A:
+		ret = int1A_handler();
+		break;
+	case 0xe6:
+		ret = intE6_handler();
+		break;
+	default:
+		break;
+	}
+
+	if (!ret)
+		ret = run_bios_int(num);
+
+	if (!ret) {
+		printf("\nint%x: not implemented\n", num);
+		//x86emu_dump_xregs();
+	}
+}
+
+unsigned char *mapitin(char *file, off_t where, size_t size)
+{
+	void *z;
+
+	int fd = open(file, O_RDWR, 0);
+
+	if (fd < 0)
+		die(file);
+	z = mmap(0, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, where);
+	if (z == (void *) -1)
+		die("mmap");
+	close(fd);
+
+	return z;
+
+}
+
+u8 x_inb(u16 port);
+u16 x_inw(u16 port);
+void x_outb(u16 port, u8 val);
+void x_outw(u16 port, u16 val);
+u32 x_inl(u16 port);
+void x_outl(u16 port, u32 val);
+
+
+X86EMU_pioFuncs myfuncs = {
+	x_inb, x_inw, x_inl,
+	x_outb, x_outw, x_outl
+};
+
+
+void usage(char *name)
+{
+	printf
+	    ("Usage: %s [-c codesegment] [-s size] [-b base] [-i ip] [-t] <filename> ... \n",
+	     name);
+}
+
+int main(int argc, char **argv)
+{
+	char *absegname = 0;
+	void *abseg = 0;
+	int i, c, trace = 0;
+	unsigned char *cp;
+	char *filename;
+	size_t size = 0;
+	int base = 0;
+	int have_size = 0, have_base = 0, have_ip = 0, have_cs = 0;
+	int have_devfn = 0;
+	int parse_rom = 0;
+	char *fsegname = 0;
+	unsigned char *fsegptr;
+	unsigned short initialip = 0, initialcs = 0, devfn = 0;
+	X86EMU_intrFuncs intFuncs[256];
+	void X86EMU_setMemBase(void *base, size_t size);
+	void X86EMU_setabseg(void *abseg);
+	void x86emu_dump_xregs(void);
+	int X86EMU_set_debug(int debug);
+	int debugflag = 0;
+
+	const char *optstring = "vh?b:i:c:s:tpd:";
+	while (1) {
+		int option_index = 0;
+		static struct option long_options[] = {
+			{"verbose", 0, 0, 'v'},
+			{"help", 0, 0, 'h'},
+			{"trace", 0, 0, 't'},
+			{"base", 1, 0, 'b'},
+			{"fseg", 1, 0, 'f'},
+			{"instructionpointer", 1, 0, 'i'},
+			{"codesegment", 1, 0, 'c'},
+			{"absegment", 1, 0, 'a'},
+			{"size", 1, 0, 's'},
+			{"parserom", 0, 0, 'p'},
+			{"device", 1, 0, 'd'},
+			{"debug", 1, 0, 'D'},
+			{0, 0, 0, 0}
+		};
+		c = getopt_long(argc, argv, optstring, long_options, &option_index);
+		if (c == -1)
+			break;
+		switch (c) {
+		case 'v':
+			verbose = 1;
+			break;
+		case 'h':
+		case '?':
+			usage(argv[0]);
+			return 0;
+		case 't':
+			trace = 1;
+			break;
+		case 'b':
+			base = strtol(optarg, 0, 0);
+			have_base = 1;
+			break;
+		case 'i':
+			initialip = strtol(optarg, 0, 0);
+			have_ip = 1;
+			break;
+		case 'c':
+			initialcs = strtol(optarg, 0, 0);
+			have_cs = 1;
+			break;
+		case 's':
+			size = strtol(optarg, 0, 0);
+			have_size = 1;
+			break;
+		case 'p':
+			printf("Parsing rom images not implemented.\n");
+			parse_rom = 1;
+			break;
+		case 'f':
+			fsegname = optarg;
+			break;
+		case 'a':
+			absegname = optarg;
+			break;
+		case 'd':
+			devfn = get_device(optarg);
+			have_devfn = 1;
+			break;
+		case 'D':
+			debugflag = strtol(optarg, 0, 0);
+			break;
+		default:
+			printf("Unknown option \n");
+			usage(argv[0]);
+			return 1;
+		}
+	}
+
+	if (optind >= argc) {
+		printf("Filename missing.\n");
+		usage(argv[0]);
+		return 1;
+	}
+
+	while (optind < argc) {
+		printf("running file %s\n", argv[optind]);
+		filename = argv[optind];
+		optind++;
+		/* normally we would do continue, but for
+		 * now only one filename is supported.
+		 */
+		/* continue; */
+		break;
+	}
+
+	if (!have_size) {
+		printf("No size specified. defaulting to 32k\n");
+		size = 32 * 1024;
+	}
+	if (!have_base) {
+		printf("No base specified. defaulting to 0xc0000\n");
+		base = 0xc0000;
+	}
+	if (!have_cs) {
+		printf("No initial code segment specified. defaulting to 0xc000\n");
+		initialcs = 0xc000;
+	}
+	if (!have_ip) {
+		printf
+		    ("No initial instruction pointer specified. defaulting to 0x0003\n");
+		initialip = 0x0003;
+	}
+
+	//printf("Point 1 int%x vector at %x\n", 0x42, getIntVect(0x42));
+
+	if (initialip == 0x0003) {
+		if ((devfn == 0) || (have_devfn == 0)) {
+			printf("WARNING! It appears you are trying to run an option ROM.\n");
+			printf("  (initial ip = 0x0003)\n");
+			if (have_devfn) {
+				printf("  However, the device you have specified is 0x00\n");
+				printf("  It is very unlikely that your device is at this address\n");
+				printf("  Please check your -d option\n");
+			}
+			else {
+				printf("  Please specify a device with -d\n");
+				printf("  The default is not likely to work\n");
+			}
+		}
+	}
+	
+	if (absegname) {
+		abseg = mapitin(absegname, (off_t) 0xa0000, 0x20000);
+		if (!abseg)
+			die(absegname);
+	}
+
+	current = &p;
+	X86EMU_setMemBase(biosmem, sizeof(biosmem));
+	X86EMU_setabseg(abseg);
+	X86EMU_setupPioFuncs(&myfuncs);
+	ioperm(0, 0x400, 1);
+
+	if (iopl(3) < 0) {
+		warn("iopl failed, continuing anyway");
+	}
+
+	/* Emergency sync ;-) */
+	sync();
+	sync();
+
+	/* Setting up interrupt environment.
+	 * basically this means initializing PCI and
+	 * intXX handlers.
+	 */
+	pciInit();
+
+	for (i = 0; i < 256; i++)
+		intFuncs[i] = do_int;
+	X86EMU_setupIntrFuncs(intFuncs);
+	cp = mapitin(filename, (off_t) 0, size);
+
+	if (devfn) {
+		printf("Loading ax with BusDevFn = %x\n",devfn);
+	}
+	
+	current->ax = devfn   ? devfn : 0xff;
+	current->dx = 0x80;
+	//      current->ip = 0;
+	for (i = 0; i < size; i++)
+		wrb(base + i, cp[i]);
+
+	if (fsegname) {
+		fsegptr = mapitin(fsegname, (off_t) 0, 0x10000);
+		for (i = 0; i < 0x10000; i++)
+			wrb(0xf0000 + i, fsegptr[i]);
+	} else {
+		char *date = "01/01/99";
+		for (i = i; date[i]; i++)
+			wrb(0xffff5 + i, date[i]);
+		wrb(0xffff7, '/');
+		wrb(0xffffa, '/');
+	}
+	/* cpu setup */
+	X86_AX = devfn ? devfn : 0xff;
+	X86_DX = 0x80;
+	X86_EIP = initialip;
+	X86_CS = initialcs;
+
+	/* Initialize stack and data segment */
+	X86_SS = 0x0030;
+	X86_DS = 0x0040;
+	X86_SP = 0xfffe;
+	/* We need a sane way to return from bios
+	 * execution. A hlt instruction and a pointer
+	 * to it, both kept on the stack, will do.
+	 */
+	pushw(0xf4f4);		/* hlt; hlt */
+	pushw(X86_SS);
+	pushw(X86_SP + 2);
+
+	X86_ES = 0x0000;
+
+	if (trace) {
+		printf("Switching to single step mode.\n");
+		//X86EMU_trace_on();
+	}
+	if (debugflag) {
+		//X86EMU_set_debug(debugflag);
+	}
+	X86EMU_exec();
+	/* Cleaning up */
+	pciExit();
+
+	return 0;
+}
+
+unsigned short get_device(char *arg_val)
+{
+	unsigned short devfn=0;
+	long bus=0,dev=0,fn=0,need_pack=0;
+	char *tok;
+	
+	tok = strsep(&arg_val,":");
+	if (arg_val != NULL) {
+		bus = strtol(tok,0,16);
+		need_pack = 1;
+	}
+	else {
+		arg_val = tok;
+	}
+
+	tok = strsep(&arg_val,".");
+	if (arg_val != NULL) {
+		dev = strtol(tok,0,16);
+		fn  = strtol(arg_val,0,16);
+		need_pack = 1;
+	}
+	else {
+		if (need_pack ==1 && (strlen(tok))) {
+			dev = strtol(tok,0,16);			
+		}
+	}
+	
+	if ( need_pack == 1) {
+		devfn = bus<<8 | (dev<<3) | fn;
+	}
+	else {
+		devfn = strtol(tok, 0, 0);
+	}
+
+
+	return devfn;
+}
+
